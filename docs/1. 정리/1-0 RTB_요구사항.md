# 광고 엔진 요구사항 정리

## 📋 프로젝트 개요

### 개발 배경
- **타임라인**: 2023.3Q 초 Citrus Ad 오픈소스 도입 → 2025.4Q 목표 자체 CPC 광고 시스템 구축
- **목적**: 회사 자체 수수료 구조 개선, 개발 대기시간 단축, Citrus Ad 기본 관리 기능 대체
- **요구사항**: Citrus Ad와 동일한 구성 및 구현, 기존 성과 이상의 광고 엔진 구축

### 핵심 구성요소 (1차 개발 범위)
- **광고 엔진 (Real-Time Bidding)**
- **노출 API**
- **어드민 시스템**
- **확장성**: 가격 실험/개인화 대응

---

> **📝 관련 문서**
> - API 및 어드민 시스템 요구사항: `docs/API_요구사항.md`

---

## ⚙️ 광고 엔진 알고리즘 요구사항

### 1. 광고 할당 (Allocation) 🎯

> **📝 쉽게 말하면**: 광고를 어디에 보여줄지 정하는 방법이에요. 마치 시험 점수로 순위를 매기는 것과 같아요!

**목적:** 광고 영역 a의 n번째 위치에 적합한 광고를 할당

#### 1-1. 할당 알고리즘 및 핵심 공식

**할당 알고리즘:**
```
Allocation (a,n) = rank(n) of R(S_α(a,i))
```

**함수 정의:**
- `R(a)`: 광고 영역 a에 해당하는 모든 광고 i에 대해서 노출 점수 S_α에 따라 정렬하는 함수

**노출 점수 계산 공식:**
```
S_α(a,i) = B(a,i) × CTR_π,δ,ω1(a,i) + α × CTR_π,δ,ω1(a,i) × CVR_π,δ,ω2,θ(a,i) × P
```

> **🧒 쉬운 설명**: 광고 점수 = 입찰가 × 클릭율 + 보너스점수

**변수 정의:**
- `B(a,i)`: 광고 영역 × 상품별로 광고주가 입력한 입찰가 
  > 💰 **쉽게 말하면**: 광고주가 "이 광고를 보여주면 이만큼 줄게!"라고 하는 돈
- `CTR_π,δ,ω1(a,i)`: 엔진 추정치로 최근 π 기간 동안 a영역에서 i 상품의 노출 대비 클릭율
  > 👆 **쉽게 말하면**: 100명이 봤을 때 몇 명이 클릭하는지 (10명이면 10%)
- `CVR_π,δ,ω2,θ(a,i)`: 엔진 추정치로 최근 π 기간 동안 a영역에서 i 상품의 클릭 대비 구매율
  > 🛒 **쉽게 말하면**: 클릭한 사람 중에서 실제로 물건을 사는 비율
- `P`: 상품 관련 가중치
- `α`: 전환율 가중치 파라미터
  > ⚖️ **쉽게 말하면**: 클릭한 사람이 실제로 물건을 사는지도 봐서 주는 추가점수

#### 1-2. 실제 계산 예시 📊

홈페이지에서 노트북 광고 3개가 경쟁하는 상황:

**광고 A (삼성 노트북)**
- B(a,i) = 1000원 (입찰가)
- CTR = 5% (0.05)
- CVR = 2% (0.02)
- α = 0.3, P = 100
- **기본점수**: 1000 × 0.05 = 50점
- **보너스점수**: 0.3 × 0.05 × 0.02 × 100 = 0.03점
- **S_α(a,i) = 50.03점**

**광고 B (LG 노트북)**
- B(a,i) = 800원, CTR = 8% (0.08), CVR = 3% (0.03)
- **기본점수**: 800 × 0.08 = 64점
- **보너스점수**: 0.3 × 0.08 × 0.03 × 100 = 0.072점
- **S_α(a,i) = 64.072점**

**광고 C (애플 노트북)**
- B(a,i) = 1200원, CTR = 3% (0.03), CVR = 4% (0.04)
- **기본점수**: 1200 × 0.03 = 36점
- **보너스점수**: 0.3 × 0.03 × 0.04 × 100 = 0.036점
- **S_α(a,i) = 36.036점**

**정렬 함수 R(a) 적용 결과:**
1. **1등: LG 노트북 (64.072점)** → rank(1)
2. **2등: 삼성 노트북 (50.03점)** → rank(2)
3. **3등: 애플 노트북 (36.036점)** → rank(3)

> **💡 분석**: 삼성이 가장 많은 돈을 냈지만, LG가 높은 클릭율로 1등을 차지했어요!

#### 1-3. 필터링 요건 및 검증 과정

**필터링 요건:**
- 잔액 > 0
- 승인/유효 캠페인
- 일예산 초과 없음
- 품절 상품 제외

**검증 로직:**
```
FOR 각 광고 IN 점수순으로:
    IF 광고주_잔액 > 0 AND
       캠페인_상태 == "승인" AND  
       일일_사용예산 < 일일_최대예산 AND
       상품_재고 > 0:
        ✅ 광고 노출 승인
    ELSE:
        ❌ 해당 광고 제외, 다음 순위 검토
```

#### 1-4. 후처리 (Post-processing) - 가격실험 지원

**후처리 공식:**
```
Post-processing(Allocation(a,n))
```

**목적:** 가격실험에 해당하는 상품의 코드를 실험군에 맞게 변환

#### 1-4-1. 입력 정보 (Input)
- **가격 실험 정보**: 실험번호와 A,B,C군 요청을 할당 및 Si parameter로 제공해야 함

#### 1-4-2. 참조 테이블 (Reference)  
- **가격실험 테이블**: 가격 실험 대상 코드, 실험번호, 실험군으로 구성된 가격실험 테이블 참조

#### 1-4-3. 후처리 로직

**STEP 1: 가격실험 대상 확인**
```
FOR 각 할당된 상품:
    IF 상품코드 IN 가격실험_대상_테이블:
        실험번호 = 가격실험_테이블[상품코드].실험번호
        A군_상품코드 = 가격실험_테이블[상품코드].A군_코드
        ✅ 가격실험 대상 상품 확인
    ELSE:
        ❌ 일반 상품 - 코드 변경 없음
```

**STEP 2: 실험군별 상품코드 변환**
```
IF 할당된_상품 == A군_상품 AND 요청된_실험군 != "A":
    IF 요청된_실험군 == "B":
        최종_상품코드 = B군_상품코드
    ELSE IF 요청된_실험군 == "C":  
        최종_상품코드 = C군_상품코드
    
    // 원본 코드 보존 (성과 집계용)
    원본_상품코드 = A군_상품코드
ELSE:
    최종_상품코드 = 원래_상품코드
```

#### 1-4-4. 실제 적용 예시

**가격실험 테이블 설정:**
| 실험번호 | A군 상품코드 | B군 상품코드 | C군 상품코드 |
|---------|-------------|-------------|-------------|
| EXP001 | SAMSUNG_NB_001 | SAMSUNG_NB_001_SALE | SAMSUNG_NB_001_PREMIUM |
| EXP002 | LG_NB_002 | LG_NB_002_DISCOUNT | LG_NB_002_BUNDLE |

**할당 결과:**
1. **1등**: LG 노트북 (LG_NB_002) ← 가격실험 대상
2. **2등**: 삼성 노트북 (SAMSUNG_NB_001) ← 가격실험 대상  
3. **3등**: 애플 노트북 (APPLE_NB_003) ← 일반 상품

**사용자 요청이 B군 실험군인 경우:**

```
후처리 결과:
1등: LG_NB_002 → LG_NB_002_DISCOUNT (B군으로 변환)
2등: SAMSUNG_NB_001 → SAMSUNG_NB_001_SALE (B군으로 변환)
3등: APPLE_NB_003 → APPLE_NB_003 (변경 없음)
```

#### 1-4-5. 성과 추적을 위한 태깅

**클릭/전환 API 로깅 시 필수 정보:**
```json
{
  "노출_상품코드": "LG_NB_002_DISCOUNT",  // 실제 노출된 코드
  "원본_상품코드": "LG_NB_002",           // 원래 상품코드 (성과 집계용)
  "실험번호": "EXP002",
  "실험군": "B",
  "클릭_시간": "2024-01-15T14:30:00Z"
}
```

> **🎯 핵심**: CTR/CVR 집계 및 어드민 대시보드를 위해, 클릭/전환 API에서 실험번호, 실험군에 해당하는 **원 상품코드를 태그**해 두어야 함

> **📊 최종 결과**: 가격실험이 적용된 상품코드들이 실험군에 맞게 변환되어 사용자에게 노출되고, 성과 분석을 위한 원본 정보도 함께 보존됩니다!

---

### 2. 가격 산정 (Pricing) 💰

> **📝 쉽게 말하면**: 광고 가격은 마치 경매와 같아요! 기본 원칙은 "나보다 한 단계 아래 사람이 낸 가격만 내면 돼요"

**목적:** 광고 영역 a의 n번째 위치의 CPC 적용가 산정

#### 2-1. 가격 산정 알고리즘

**가격 산정 공식:**
```
Pricing(a,n) = min(B(a,n), B(a,n+1))
```

> **🧒 쉬운 설명**: 지불가격 = MIN(내가 낸 가격, 다음 순위가 낸 가격)

**특수 케이스:**
- 품질 점수가 낮아서 입찰가가 역전되는 경우, 자신의 입찰가를 사용

#### 2-2. 실제 계산 예시

앞서 계산한 노트북 광고 순서를 사용:

**할당 결과 (점수 기준 순위):**
1. **LG 노트북**: 64.072점, B(a,1) = 800원
2. **삼성 노트북**: 50.03점, B(a,2) = 1000원  
3. **애플 노트북**: 36.036점, B(a,3) = 1200원

**가격 계산 과정:**

**1등 LG 노트북이 클릭될 때:**
```
Pricing(a,1) = min(B(a,1), B(a,2)) = min(800, 1000) = 800원
```
- **실제 지불**: 800원 (자신의 입찰가)

**2등 삼성 노트북이 클릭될 때:**
```
Pricing(a,2) = min(B(a,2), B(a,3)) = min(1000, 1200) = 1000원
```
- **실제 지불**: 1000원 (자신의 입찰가)

**3등 애플 노트북이 클릭될 때:**
```
Pricing(a,3) = min(B(a,3), null) = 1200원
```
- **실제 지불**: 1200원 (다음 순위 없음)

> **🤔 특별한 케이스 분석**: 이 경우 모든 광고가 자신의 입찰가를 지불해요. 왜냐하면 점수가 높은 순서와 입찰가가 높은 순서가 다르기 때문이에요! (입찰가 역전 현상)

#### 2-3. 일반적인 경우와 비교

**만약 입찰가 순서대로 점수도 나왔다면:**

가정: 애플(1등) → 삼성(2등) → LG(3등)

1. **애플**: Pricing(a,1) = min(1200, 1000) = **1000원만 지불**
2. **삼성**: Pricing(a,2) = min(1000, 800) = **800원만 지불**  
3. **LG**: Pricing(a,3) = 800원 (다음 순위 없음)

> **💡 이해하기**: 일반적으로는 높은 순위일수록 더 적은 가격을 지불하게 되어 있어요!

#### 2-4. 가격 적용 방식 및 시스템 연동

**적용 방식:**
- 클릭 시 차감을 진행하기 위해, 노출 시 산정된 적용가가 반영 필요
- Request API에서 가격 기록
- Tracking API에서 적용가 반영한 logging 및 잔액 차감 필요

**전체 시스템 흐름:**
```
STEP 1: 광고 요청 (Request API)
        → 할당 알고리즘으로 순위 결정
        → 가격 산정 알고리즘으로 CPC 계산
        → 광고 ID와 적용가격 매핑 저장

STEP 2: 광고 노출
        → Tracking API에 impression 이벤트 전송

STEP 3: 사용자 클릭
        → Tracking API에 click 이벤트 전송
        → 미리 계산된 적용가격으로 잔액 차감
        → 로깅 및 성과 집계
```

> **🎯 핵심**: 공정한 경쟁을 위해 경매 방식을 사용하되, 과도한 지불을 방지하는 스마트한 가격 결정 시스템입니다!

---

### 3. 방어로직 및 안전장치 🛡️

> **📝 쉽게 말하면**: 새로운 상품이거나 데이터가 부족할 때 시스템이 멈추지 않도록 하는 안전장치예요. 마치 새 학생이 전학 왔을 때 반 평균 점수를 주고 시작하는 것과 같아요!

#### 3-1. 방어로직 기본 설정

**CTR, CVR 값 부족 시 평균값 적용:**
- `ω1` (노출 임계): 1시간 평균 이하 시 CTR = 방어값
- `ω2` (클릭 임계): 1시간 평균 이하 시 CVR = 방어값
- `δ`: 방어값 추정법 (평균 or 최소)

#### 3-2. 데이터 충분성 체크 로직

```
STEP 1: 데이터 충분성 체크
FOR 각 광고:
    최근_노출수 = 지난 π 기간 동안의 노출 횟수
    최근_클릭수 = 지난 π 기간 동안의 클릭 횟수
    
    IF 최근_노출수 < ω1_임계값:  // 예: 100회 미만
        ❌ CTR 데이터 부족! → 방어값 적용
    
    IF 최근_클릭수 < ω2_임계값:  // 예: 10회 미만  
        ❌ CVR 데이터 부족! → 방어값 적용
```

#### 3-3. 방어값 계산 및 적용

**방어값 계산 방법:**

**경우 1: CTR 데이터 부족**
```
IF 노출수 < ω1_임계값:
    IF δ == "평균":
        CTR_π,δ,ω1(a,i) = 카테고리_평균_CTR
    ELSE IF δ == "최소":
        CTR_π,δ,ω1(a,i) = 카테고리_최소_CTR
```

**경우 2: CVR 데이터 부족**
```
IF 클릭수 < ω2_임계값:
    IF δ == "평균":
        CVR_π,δ,ω2,θ(a,i) = 카테고리_평균_CVR
    ELSE IF δ == "최소":
        CVR_π,δ,ω2,θ(a,i) = 카테고리_최소_CVR
```

#### 3-4. 실제 적용 예시

**새로운 게임 광고 등록 상황:**
- 지난 π 기간 노출: 50회 (ω1 임계값 100회 < 50회) ❌
- 지난 π 기간 클릭: 3회 (ω2 임계값 10회 < 3회) ❌

**카테고리별 통계 (게임 카테고리):**
- 평균 CTR: 6%, 최소 CTR: 2%
- 평균 CVR: 2%, 최소 CVR: 0.5%

**δ = "평균" 방식 적용:**
```
새 게임 광고 점수 계산:
S_α(게임,새상품) = 800 × 0.06 + 0.3 × 0.06 × 0.02 × 100
                = 48 + 0.036 = 48.036점
```

**δ = "최소" 방식 적용:**
```
새 게임 광고 점수 계산:
S_α(게임,새상품) = 800 × 0.02 + 0.3 × 0.02 × 0.005 × 100  
                = 16 + 0.003 = 16.003점
```

> **💡 선택 기준**: "평균" 방식은 새 상품에게 공정한 기회를, "최소" 방식은 위험을 최소화하는 보수적 접근을 제공합니다.

### 4. 파라미터 관리 ⚙️

**초기 설정:**
- 파라미터 `α`, `π`는 기존 시스템의 세팅으로 런칭
- 추후 고도화를 위해서 변경 가능한 구조 필요

**파라미터 의미:**
- `α`: 전환율 가중치 (클릭보다 구매를 얼마나 중요하게 볼지)
- `π`: 데이터 수집 기간 (최근 몇 시간/일의 데이터를 사용할지)
- `ω1`: CTR 계산을 위한 최소 노출 임계값
- `ω2`: CVR 계산을 위한 최소 클릭 임계값

### 5. 필터링 요건 ✅

**기본 필터링 조건:**
- 잔액 > 0
- 승인/유효 캠페인
- 일예산 초과 없음
- 품절 상품 제외

**통합 알고리즘 흐름:**
```
FOR 각 광고 점수 계산시:
    // 1단계: 기본 필터링
    IF NOT (잔액 > 0 AND 캠페인_승인 AND 예산_여유 AND 재고_있음):
        CONTINUE (다음 광고로)
    
    // 2단계: 데이터 충분성 체크 및 방어값 적용
    IF 충분한 노출/클릭 데이터 있음:
        실제_CTR, 실제_CVR 사용
    ELSE:
        방어_CTR, 방어_CVR 적용
        
    // 3단계: 점수 계산
    광고점수 = B(a,i) × CTR + α × CTR × CVR × P
    
    // 4단계: 최종 순위 결정
    순위리스트에 추가
```

> **🎯 목표**: 안정적이고 공정한 광고 경쟁 환경을 제공하여 모든 광고주가 참여할 수 있는 시스템을 구축합니다!

---

## 🔮 확장 요건

### 1. 가격 실험
- 실험 키(`exp_key`), 실험군(`exp_var`) 기반 상품 코드 변환 필요
- 클릭/구매 로그에 실험 정보 태깅 필수

### 2. 개인화
- **Lv1**: 클릭 recency, 노출 frequency 기반 retargeting
- **Lv2**: 유저별 CTR/CVR 추정
- **Lv3**: 머신러닝 모델 확장 가능성 고려 (현재는 보류)

### 3. Migration 계획
- Citrus Ad 시스템에서 기존 데이터 동기화 모듈 개발
- 초기 파라미터 추정 작업 수행
- A/B 테스트로 기존 대비 성능 검증 예정

---

> **📝 성능 요구사항은 `docs/API_요구사항.md` 파일을 참고하세요.** 
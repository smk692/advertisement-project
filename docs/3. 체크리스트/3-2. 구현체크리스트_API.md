# API 서버 구현 체크리스트 (업데이트)

> **API 서버 책임 범위**: 
> - HTTP 요청 처리 및 즉시 응답 (3-5ms Cache Hit, 15-20ms Cache Miss)
> - RTB 로직 실행 (광고 매칭/가격 결정)  
> - Redis 기반 선차감 처리
> - Kafka 이벤트 발행 (비동기)
> - **기술 스택**: Kotlin + Spring Boot + Redis + Kafka
> - **설계 원칙**: FK 제약조건 없음, 논리적 연결만 유지

---

## 📋 API 목록 및 성능 목표

| 구분         | 엔드포인트                                      | 메서드   | 주요 기능                                     | 목표 응답시간 |
|--------------|------------------------------------------------|----------|-----------------------------------------------|---------------|
| 광고 서빙    | /api/v1/ads/request                            | POST     | 광고 요청(RTB 캐시 조회 + 가격실험 후처리)     | Cache Hit: 3-5ms<br/>Cache Miss: 15-20ms ⚠️ |
| 이벤트 추적  | /api/v1/ads/impression                         | POST     | 노출 이벤트 기록, Kafka 전송                   | < 30ms        |
| 이벤트 추적  | /api/v1/ads/click                              | POST     | Redis 선차감, Kafka 전송                       | < 30ms        |
| 이벤트 추적  | /api/v1/ads/conversion                         | POST     | 전환 이벤트 기록, Kafka 전송                   | < 30ms        |
| 어드민       | /admin/v1/advertisers                          | POST     | 광고주 등록                                   | < 200ms       |
| 어드민       | /admin/v1/advertisers/{id}/balance             | PUT      | 광고주 잔액 충전/차감                         | < 100ms       |
| 어드민       | /admin/v1/advertisers/{id}/balance             | GET      | 잔액/일예산 현황 조회                         | < 100ms       |
| 어드민       | /admin/v1/campaigns                            | POST     | 캠페인 등록                                   | < 200ms       |
| 어드민       | /admin/v1/campaigns/{id}/budget                | GET      | 예산 현황 조회                                | < 100ms       |
| 어드민       | /admin/v1/advertisers/{id}/dashboard           | GET      | 광고주 대시보드                               | < 500ms       |
| 어드민       | /admin/v1/monitoring/realtime                  | GET      | 시스템 실시간 모니터링                        | < 100ms       |

---

## 🚀 광고 서빙 API

### ✅ 1. 광고 요청 API

**📌 API 설명**
```
목적: 사용자의 광고 요청에 대해 실시간으로 최적의 광고를 선택하여 반환
역할: CPC 광고 시스템의 핵심 엔진, RTB(Real-Time Bidding) 처리
입력: 사용자 컨텍스트 (검색어, 카테고리, 디바이스 등)
출력: 최적화된 광고 목록 (가격, 순위 포함)
특징: 50ms 이내 응답, 실시간 예산/잔액 체크, A/B 테스트 지원
데이터 연결: FK 없이 논리적 조인으로 성능 최적화
```

**🎯 API 구현 체크리스트**
- [ ] **요청 검증**
  - [ ] 필수 파라미터 존재 여부 (기기ID, 세션ID, 배치위치)
  - [ ] 배치위치 값 유효성 검사 (HOME|CATEGORY|SEARCH|PRODUCT_DETAIL)
  - [ ] 최대광고수 범위 체크 (1~10)
  - [ ] 실험 키/변수 조합 유효성 검증
  - [ ] 요청 횟수 제한 적용 (rate limiting)

**🔧 RTB 로직 (실시간 조회 + 가격실험 후처리) - 아키텍처 기반**

- [ ] **1단계: 요청 검증 및 전처리**
  ```
  검증 항목:
  - 기기ID: 36자 UUID 형식 확인
  - 세션ID: 세션 유효성 및 만료 시간 체크
  - 배치위치: ENUM 값 검증 (HOME|CATEGORY|PRODUCT_DETAIL|SEARCH)
  - 검색어: SEARCH 배치위치인 경우 필수, 2-100자 제한
  - 카테고리: CATEGORY 배치위치인 경우 필수
  - 실험키, 실험변수: 실험 진행 중인 경우 매핑 테이블 존재 확인
  - 최대광고수: 1-10 범위, 기본값 3
  
  전처리:
  - 검색어 정규화 (공백 제거, 소문자 변환)
  - 카테고리 계층 구조 파싱
  - 실험 그룹 할당 검증
  ```

- [ ] **2단계: Redis RTB 캐시 조회 (단순 조회만)**
  ```
  ⭐ 아키텍처 정정: 가격은 이미 STEP 1에서 Flink가 계산 완료
  
  🎯 캐시 히트 시나리오 (95% 케이스 - 3-5ms 목표):
  1. 사전 계산된 RTB 결과 조회
     Redis Key: rtb:{placement}:{category}
     Value: [
       {campaign_id: 100, product_id: "SAMSUNG_NB_001", calculated_price: 1200, rank: 1},
       {campaign_id: 101, product_id: "LG_TV_002", calculated_price: 1100, rank: 2}
     ]
     
  2. 병렬 상태 확인 (동시 실행으로 성능 최적화)
     Promise.all([
       Redis.get(balance:{advertiser_id_1}),
       Redis.get(balance:{advertiser_id_2}),
       Redis.get(daily_spent:{campaign_id_1}:{date}),
       Redis.get(daily_spent:{campaign_id_2}:{date})
     ])
     
  3. 유효 광고 필터링 (계산 없이 필터링만)
     - 잔액 충분한 광고주의 캠페인만
     - 일예산 여유 있는 캠페인만
     - activated = 1 상태인 캠페인만
  
  ❌ 캐시 미스 시나리오 (5% 케이스 - 15-20ms):
  1. DB Fallback 조회 (기본 광고만)
     - ad_campaigns에서 기본 활성 캠페인 조회
     - 입찰가 기준 단순 정렬 (품질점수 없이)
     
  2. 캐시 재생성 요청 (중요!)
     - campaign-events 토픽에 재계산 이벤트 발행
     - Flink가 STEP 1 로직으로 재계산 수행
  ```

- [ ] **3단계: 실시간 잔액/예산 검증**
  ```
  병렬 검증 로직 (성능 최적화):
  1. 비동기 병렬 조회
     const checks = await Promise.all([
       redis.get(`balance:${advertiser_id}`),
       redis.get(`daily_spent:${campaign_id}:${date}`)
     ]);
     
  2. 예상 비용 계산
     예상비용 = 캠페인입찰가 * 예상클릭률
     
  3. 필터링 조건
     - 잔액 >= 예상비용
     - 일사용량 + 예상비용 <= 일예산
     - 캠페인 상태 = 'ACTIVE'
  ```

- [ ] **4단계: 가격실험 후처리 (아키텍처 핵심)**
  ```
  ⭐ 신규 추가: 아키텍처 STEP 2 가격실험 후처리 반영
  
  실험 처리 플로우:
  1. 할당된 상품의 실험 여부 확인
     if (exp_key != null && exp_var != null):
         실험 대상 상품 필터링
         
  2. 실험 매핑 테이블 조회
     SELECT 실험상품코드, 원본상품코드 
     FROM experiment_mapping 
     WHERE exp_key = ? AND exp_var = ? 
     AND 원본상품ID IN (할당된 상품 목록)
     AND activated = 1
     AND start_date <= NOW() <= end_date
     
  3. 실험군별 코드 변환
     원본: SAMSUNG_NB_001
     실험: SAMSUNG_NB_001_SALE (할인 실험군)
     
     for each 할당된_상품:
         if (실험_매핑_존재):
             상품코드 = 실험상품코드
         else:
             상품코드 = 원본상품코드
             
  4. 원본코드-실험코드 매핑 저장 (추적용)
     Redis: experiment:mapping:{session_id} = {
       "SAMSUNG_NB_001_SALE": "SAMSUNG_NB_001",
       "원본추적": "실험추적"
     }
     TTL: 24시간 (클릭-전환 매칭용)
     
  5. 실험 참여 로깅
     - 실험 그룹 배정 기록
     - 상품 코드 변환 로그
     - A/B 테스트 분석용 데이터
     
  6. 후처리(Post-processing) 적용 ⭐ 요구사항 필수
     - Post-processing(Allocation(a,n)) 함수 실행
     - 최종 상품 코드 확정 (실험군 코드 or 원본 코드)
     - 노출 시 산정된 적용가 기록 (클릭 시 차감용)
  ```

- [ ] **5단계: 가격 정보 추출 (계산 없음)**
  ```
  ⚠️ 수정: 가격은 STEP 1에서 이미 계산됨, 단순 추출만
  
  가격 정보 처리:
  1. 캐시 히트: 사전 계산된 가격 사용
     RTB 캐시에서 calculated_price 필드 추출
     → 이미 Pricing(a,n) = min(B(a,n), B(a,n+1)) 적용됨
     
  2. 캐시 미스: 입찰가 기본값 사용  
     - 임시 가격 = 캠페인 입찰가 (정확한 계산은 Flink에서)
     - 캐시 재생성 후 정확한 가격 적용
     
     3. 가격 정보 불필요 (단순화)
      - 요구사항: [productID, ad_ID] 배열만 반환
      - 클릭시 ad_ID로 현재 캠페인 정보 조회하여 차감
  ```

- [ ] **6단계: 최종 응답 생성**
  ```
  ⚠️ 응답 형식 검증 필요 - 요구사항 기준 단순화
  
  요구사항 명세: [productID, ad_ID] 배열
  → 기본 응답:
  [
    ["SAMSUNG_NB_001_SALE", "ad_001"],
    ["LG_TV_002_SALE", "ad_002"]
  ]
  
  → 확장 응답 (추적/실험 정보 포함):
  [
    {
      "product_id": "SAMSUNG_NB_001_SALE",
      "ad_id": "ad_001",
      "original_product_id": "SAMSUNG_NB_001",
      "experiment_applied": true
    }
  ]
  
  응답 최적화:
  - 캐시 히트: 3-5ms 목표
  - 캐시 미스: 8-12ms 목표  
  - 병렬 처리로 지연 최소화
  - 공통 필드 포함 (activated, created_at, updated_at)
  ```

- [ ] **응답 생성 (공통 필드 포함)**
  - [ ] 광고 메타데이터 포함
  - [ ] 추적용 파라미터 생성
  - [ ] 공통 필드 (activated, created_at, updated_at) 포함
  - [ ] 응답 시간 측정 및 포함

---

## 📊 이벤트 추적 API

### ✅ 2. 노출 추적 API

**📌 API 설명**
```
목적: 사용자에게 광고가 실제로 노출되었음을 기록
역할: CTR 계산의 분모 데이터 수집, 광고 성과 측정 기준점
입력: 광고ID, 요청ID, 노출시간
출력: 즉시 성공 응답 (200 OK)
Kafka: ad-events 토픽으로 IMPRESSION 이벤트 발행
```

**🎯 API 구현 체크리스트**
- [ ] **요청 검증**
  - [ ] 광고ID 존재 및 유효성 검사 (논리적 검증)
  - [ ] 요청ID 매칭 확인
  - [ ] 노출시간 형식 검증

- [ ] **이벤트 처리**
  - [ ] 노출 이벤트 객체 생성
  - [ ] 필수 필드 누락 검사
  - [ ] 이벤트 정규화 처리

- [ ] **Kafka 발행 (토픽 설계 반영)**
  ```
  ⭐ 업데이트: 통합 ad-events 토픽 사용
  
  토픽: ad-events
  이벤트 타입: IMPRESSION
  파티셔닝: device_id 기준 (24시간 매칭 최적화)
  
  스키마:
  {
    "event_type": "IMPRESSION",
    "timestamp": "2024-01-15T10:30:00Z",
    "device_id": "device_12345",
    "session_id": "session_67890",
    "ad_id": "ad_001",
    "campaign_id": "campaign_100",
    "advertiser_id": "advertiser_50",
    "product_id": "product_200",
    "placement": "HOME|CATEGORY|PRODUCT_DETAIL|SEARCH",
    "bid_price": 1500,
    "actual_price": 1200,
    "search_term": "노트북",
    "category": "전자제품/컴퓨터"
  }
  ```
  - [ ] 발행 실패 시 로깅
  - [ ] 즉시 200 OK 응답

### ✅ 3. 클릭 추적 API

**📌 API 설명**
```
목적: 사용자의 광고 클릭 시 실시간으로 비용을 차감하고 이벤트를 기록
역할: CPC 과금의 핵심, 광고주 잔액에서 즉시 클릭 비용 차감
입력: 광고ID, 기기ID, 클릭시간
출력: 차감 성공/실패 결과, 잔여 잔액 정보
특징: 30ms 이내 응답, Redis 기반 원자적 트랜잭션, 중복 클릭 방지
아키텍처: Worker와 Flink가 ad-events를 이중 소비
```

**🎯 API 구현 체크리스트**
- [ ] **중복 클릭 방지**
  - [ ] Redis에 클릭 키 생성 (광고ID + 기기ID + 클릭시간)
  - [ ] SETNX로 중복 체크 (1시간 TTL)
  - [ ] 중복 시 즉시 실패 응답

- [ ] **클릭시 실시간 캠페인 정보 조회**
  ```
  ⭐ 단순화: ad_ID로 현재 캠페인 상태 및 가격 조회
  
  1. ad_ID로 캠페인 정보 조회
     ad_campaigns 테이블에서 campaign_id, advertiser_id 검색
     
  2. 현재 입찰가 조회
     ad_placement_bids에서 현재 설정된 입찰가 조회
     현재 캠페인 상태 확인 (ACTIVE, 예산 여유 등)
     
  3. 실시간 가격 적용
     - Flink 캐시에 계산된 가격이 있으면 사용
     - 없으면 현재 입찰가 사용
     - 더 간단: 항상 현재 입찰가 사용
  ```

**🔧 Redis 선차감 로직 (MULTI/EXEC 트랜잭션)**

- [ ] **Redis 트랜잭션 처리 상세**
  ```
  1. 트랜잭션 시작
     MULTI
     
  2. 현재 상태 조회 (트랜잭션 큐에 추가)
     잔액키 = "balance:{광고주ID}"
     일예산키 = "daily_spent:{캠페인ID}:{YYYY-MM-DD}"
     
     GET {잔액키}           # 현재 잔액 조회
     GET {일예산키}         # 오늘 사용량 조회
     
  3. 잔액 차감 명령 (트랜잭션 큐에 추가)
     DECRBY {잔액키} {클릭금액}
     
  4. 일예산 카운터 증가 (트랜잭션 큐에 추가)
     INCRBY {일예산키} {클릭금액}
     EXPIRE {일예산키} 86400
     
  5. 트랜잭션 실행
     결과 = EXEC
     
  6. 결과 검증
     if (결과 == null || 결과.isEmpty()):
         트랜잭션 실패 - 재시도 또는 에러
     else:
         원본잔액 = 결과[0]
         일사용량 = 결과[1] 
         신규잔액 = 결과[2]
         
  7. 잔액 부족 체크 (애플리케이션 레벨)
     if (원본잔액 < 클릭금액):
         # 롤백 처리
         MULTI
         INCRBY {잔액키} {클릭금액}     # 잔액 복구
         DECRBY {일예산키} {클릭금액}   # 일예산 복구
         EXEC
         
         return "잔액부족"
  ```

- [ ] **Redis 키 구조 및 데이터 타입**
  ```
  잔액 관리:
  - Key: balance:{광고주ID}
  - Type: STRING (숫자)
  - Value: 현재 잔액 (정수, 원 단위)
  - TTL: 없음 (영구 보관)
  
  일예산 카운터:
  - Key: daily_spent:{캠페인ID}:{YYYY-MM-DD}
  - Type: STRING (숫자)  
  - Value: 오늘 사용 금액 (정수, 원 단위)
  - TTL: 86400초 (24시간)
  
  중복 클릭 방지:
  - Key: click:{광고ID}:{기기ID}:{클릭시간}
  - Type: STRING
  - Value: "1"
  - TTL: 3600초 (1시간)
  
  RTB 캐시 (Flink 계산 결과):
  - Key: rtb:{placement}:{category}
  - Type: ZSET (점수순 정렬)
  - Value: 캠페인ID, Score: S_α 점수
  
  방어로직 기준값:
  - Key: defense:category:{level}:ctr
  - Key: defense:category:{level}:cvr
  - Type: STRING (숫자)
  - Value: 평균/최소값
  ```

- [ ] **응답 처리**
  - [ ] 성공 시: 차감 금액, 남은 잔액 포함
  - [ ] 실패 시: 실패 사유 포함
  - [ ] 즉시 응답 반환 (동기)

- [ ] **Kafka 이벤트 발행** (비동기)
  ```
  ⭐ 업데이트: ad-events 토픽으로 CLICK 이벤트 발행
  
  역할 분담:
  - Worker: 실시간 잔액 차감 (간단한 작업)
  - Flink: 성과 집계 및 전환 매칭 (복잡한 작업)
  
  이벤트 스키마:
  {
    "event_type": "CLICK",
    "timestamp": "2024-01-15T10:30:00Z",
    "device_id": "device_12345",
    "session_id": "session_67890",
    "ad_id": "ad_001",
    "campaign_id": "campaign_100",
    "advertiser_id": "advertiser_50",
    "product_id": "product_200",
    "placement": "HOME",
    "bid_price": 1500,
    "actual_price": 1200,
    "balance_deducted": true,
    "remaining_balance": 850000
  }
  ```
  - [ ] 별도 스레드/코루틴에서 처리
  - [ ] 차감 성공/실패 상태 포함
  - [ ] 발행 실패 시 로컬 큐 백업

### ✅ 4. 전환 추적 API

**📌 API 설명**
```
목적: 사용자의 구매/전환 행동을 광고 클릭과 연결하여 기록
역할: CVR 계산과 광고 효과 측정, ROI 분석의 기준 데이터
입력: 기기ID, 세션ID, 주문 정보
출력: 즉시 성공 응답 (200 OK)
특징: 24시간 내 클릭-전환 매칭, 상품별 전환 추적
아키텍처: conversion-events와 ad-events를 Flink에서 24시간 윈도우 조인
```

**🎯 API 구현 체크리스트**
- [ ] **요청 검증**
  - [ ] 기기ID, 세션ID 존재 확인
  - [ ] 상품 정보 배열 검증
  - [ ] 가격 정보 유효성 검사

- [ ] **이벤트 처리**
  - [ ] 24시간 매칭용 세션 정보 포함
  - [ ] 상품별 전환 정보 정리
  - [ ] 전환 이벤트 객체 생성

- [ ] **Kafka 발행 (별도 토픽)**
  ```
  ⭐ 업데이트: conversion-events 별도 토픽 사용
  
  토픽: conversion-events
  파티셔닝: device_id 기준 (ad-events와 동일)
  
  스키마:
  {
    "timestamp": "2024-01-15T14:30:00Z",
    "device_id": "device_12345",
    "session_id": "session_67890",
    "order_id": "order_789",
    "product_id": "product_200",
    "revenue_amount": 50000,
    "conversion_type": "PURCHASE|ADD_TO_CART|SIGNUP",
    "attribution_window": 24,
    "referrer_url": "https://example.com/product/200"
  }
  ```
  - [ ] 즉시 200 OK 응답

---

## 🏢 어드민 API

### ✅ 5. 광고주 등록 API

**🎯 API 구현 체크리스트**
- [ ] **입력 검증**
  - [ ] 사업자번호 형식 검증
  - [ ] 이메일 형식 검증
  - [ ] 필수 필드 누락 검사
  - [ ] 사업자번호 중복 검사

- [ ] **데이터 저장 (공통 필드 포함)**
  ```
  
  INSERT INTO ad_advertisers (
    advertiser_name, business_type, status,
    activated, created_at, updated_at, 
    created_user_id, updated_user_id
  ) VALUES (
    ?, ?, 'ACTIVE',
    1, NOW(), NOW(),
    ?, ?
  )
  ```
  - [ ] 광고주 테이블에 저장
  - [ ] 고유 ID 생성
  - [ ] 초기 잔액 설정 (옵션)
  - [ ] 공통 필드 설정 (activated=1, 생성자/수정자 ID)

- [ ] **Redis 동기화**
  - [ ] 잔액 정보 Redis에 저장
  - [ ] 광고주 메타데이터 캐싱

### ✅ 6. 잔액 관리 API

**🎯 API 구현 체크리스트**
- [ ] **입력 검증**
  - [ ] action 타입 검증 (charge|deduct)
  - [ ] 금액 양수 검증
  - [ ] 광고주 존재 여부 확인 (activated=1)

- [ ] **잔액 처리 (공통 필드 업데이트)**
  ```
  
  1. 광고주 존재 확인
     SELECT COUNT(*) FROM ad_advertisers 
     WHERE id = ? AND activated = 1
     
  2. 잔액 업데이트 (공통 필드 포함)
     UPDATE ad_balances SET
       current_balance = current_balance + ?,
       updated_at = NOW(),
       updated_user_id = ?
     WHERE advertiser_id = ?
     
  3. 이력 기록 (공통 필드 포함)
     INSERT INTO ad_balance_histories (
       advertiser_id, transaction_type, amount,
       balance_before, balance_after,
       activated, created_at, created_user_id
     ) VALUES (?, ?, ?, ?, ?, 1, NOW(), ?)
  ```
  - [ ] DB 트랜잭션으로 잔액 업데이트
  - [ ] 차감 시 잔액 부족 검사
  - [ ] 변경 이력 테이블에 기록

- [ ] **Redis 동기화**
  - [ ] DB 업데이트 성공 후 Redis 업데이트
  - [ ] 동기화 실패 시 알림

### ✅ 7. 캠페인 등록 API

**🎯 API 구현 체크리스트**
- [ ] **입력 검증 (논리적 연결)**
  ```
  
  1. 광고주 존재 확인
     SELECT COUNT(*) FROM ad_advertisers 
     WHERE id = ? AND activated = 1
     
  2. 상품 존재 확인 (해당하는 경우)
     SELECT COUNT(*) FROM ad_products_meta 
     WHERE product_id = ? AND activated = 1
  ```
  - [ ] 예산 금액 양수 검증
  - [ ] 시작/종료 날짜 유효성 검사
  - [ ] 타겟 키워드 형식 검증

- [ ] **데이터 저장 (공통 필드 포함)**
  ```
  INSERT INTO ad_campaigns (
    advertiser_id, campaign_name, campaign_type, status,
    start_date, end_date, daily_budget, total_budget,
    activated, created_at, updated_at,
    created_user_id, updated_user_id
  ) VALUES (
    ?, ?, ?, 'PENDING',
    ?, ?, ?, ?,
    1, NOW(), NOW(),
    ?, ?
  )
  ```
  - [ ] 캠페인 테이블에 저장
  - [ ] 타겟팅 조건 저장
  - [ ] 상태를 PENDING으로 설정 (승인 필요)

- [ ] **Kafka 이벤트 발행**
  ```
  ⭐ 업데이트: campaign-events 토픽으로 이벤트 발행
  
  이벤트 타입: CAMPAIGN_CREATED
  역할: Flink RTB Statement가 처리하여 Redis 순위 캐시 업데이트
  ```
  - [ ] campaign-events 토픽으로 CAMPAIGN_CREATED 이벤트 발행
  - [ ] RTB 재계산 트리거

---

## 🚨 공통 구현 체크리스트

### ✅ 12. 데이터 무결성 관리 (FK 없는 환경)

**🔧 논리적 연결 관리**
- [ ] **참조 무결성 체크**
  ```
  ⭐ 신규: FK 제약 없이 애플리케이션 레벨에서 무결성 보장
  
  1. 삽입 전 참조 테이블 존재 확인
     if (advertiser_id != null):
         SELECT COUNT(*) FROM ad_advertisers 
         WHERE id = ? AND activated = 1
         
  2. 논리적 조인 시 NULL 체크
     LEFT JOIN 대신 EXISTS 사용으로 성능 최적화
     
  3. 배치 정합성 체크 (일 1회)
     고아 레코드 및 불일치 데이터 탐지 및 알림
  ```

  ```
  ⭐ 신규: 모든 테이블 표준화
  
  1. INSERT/UPDATE 시 공통 필드 자동 설정
     activated = 1 (기본값)
     created_at = NOW() (삽입 시)
     updated_at = NOW() (갱신 시)
     created_user_id = {로그인 사용자}
     updated_user_id = {로그인 사용자}
     
  2. Soft Delete 지원
     DELETE 대신 activated = 0 으로 논리 삭제
     
  3. 변경 추적 지원
     updated_at, updated_user_id로 변경 이력 추적
  ```

### ✅ 13. 예외 처리

**🔧 필수 예외 처리**
- [ ] **잔액 부족 예외**
  - [ ] 명확한 에러 메시지
  - [ ] 현재 잔액 정보 포함
  - [ ] 로깅 처리

- [ ] **논리적 연결 실패 예외**
  ```
  ⭐ 신규: FK 없는 환경의 예외 처리
  
  1. 참조 데이터 누락
     - 에러 코드: REFERENCE_NOT_FOUND
     - 메시지: "참조된 {테이블}의 {ID}가 존재하지 않습니다"
     
  2. 비활성화된 참조 데이터
     - 에러 코드: REFERENCE_INACTIVE
     - 메시지: "참조된 {테이블}이 비활성화 상태입니다"
  ```

### ✅ 14. 모니터링 및 로깅

**🔧 필수 모니터링**
- [ ] **비즈니스 메트릭**
  - [ ] 잔액 차감 성공률
  - [ ] 광고 매칭 성공률
  - [ ] 예산 소진율
  - [ ] 실험 참여율
  - [ ] 방어로직 적용률 (신규)

- [ ] **데이터 무결성 메트릭 (신규)**
  ```
  ⭐ 신규: FK 없는 환경의 무결성 모니터링
  
  1. 고아 레코드 탐지율
     - 참조 데이터가 없는 레코드 비율
     - 일일 배치로 체크 및 알림
     
  2. 논리적 조인 실패율
     - API 호출 시 참조 실패 비율
     - 실시간 모니터링 및 알람
     
  3. 공통 필드 누락률
     - activated, created_at 등 누락 비율
     - 데이터 품질 지표
  ```

---

## 🔧 성능 최적화 체크리스트 (업데이트)

### ✅ 15. Redis 캐시 최적화 (아키텍처 기반)

**🔧 캐시 전략**
- [ ] **RTB 결과 캐싱 (Flink 사전 계산)**
  ```
  ⭐ 아키텍처 반영: STEP 2 실시간 조회 최적화
  
  Primary Key 구조:
  - rtb:{placement}:{category} = [
      {campaign_id: 100, calculated_price: 1200, rank: 1},
      {campaign_id: 101, calculated_price: 1100, rank: 2}
    ]
  - balance:{advertiser_id} = {현재잔액}
  - daily_spent:{campaign_id}:{YYYY-MM-DD} = {소진금액}
  
  실험 관련 Key:
  - experiment:mapping:{session_id} = {원본코드: 실험코드}
  - experiment:active:{exp_key} = [활성 실험 변수 목록]
  
  방어로직 Key:
  - defense:category:{level}:ctr = {평균/최소값}
  - defense:category:{level}:cvr = {평균/최소값}
  ```

- [ ] **병렬 조회 최적화**
  ```
  ⭐ 신규: 아키텍처 병렬 처리 패턴
  
  1. Promise.all() 활용
     const [rtbData, balanceData, budgetData] = await Promise.all([
       redis.get(`rtb:${placement}:${category}`),
       redis.mget(advertiserIds.map(id => `balance:${id}`)),
       redis.mget(campaignIds.map(id => `daily_spent:${id}:${date}`))
     ]);
     
  2. Pipeline 사용
     const pipeline = redis.pipeline();
     pipeline.get(`rtb:${placement}:${category}`);
     pipeline.get(`balance:${advertiser_id}`);
     pipeline.get(`daily_spent:${campaign_id}:${date}`);
     const results = await pipeline.exec();
     
  3. Connection Pool 최적화
     - 최소 10개, 최대 50개 연결
     - Idle timeout: 30초
     - Max retry: 3회
  ```

- [ ] **캐시 무효화 전략**
  - [ ] 캠페인 변경 시 관련 RTB 캐시 삭제 (Flink 트리거)
  - [ ] TTL 기반 자동 만료 (RTB: 5분, 실험매핑: 24시간)
  - [ ] 메모리 사용량 모니터링 (80% 임계치)